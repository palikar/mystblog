<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Projects on Stanislav Arnaudov</title>
    <link>/projects/</link>
    <description>Recent content in Projects on Stanislav Arnaudov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="/projects/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AssetBuilder</title>
      <link>/projects/assetbuilder/</link>
      <pubDate>Wed, 28 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>/projects/assetbuilder/</guid>
      <description>Abstract AssetBuilder is my solution for quickly loading assets in some applications in DirectXer. There is a lot that needs to happen for an image to be turned into a texture on the GPU. Most of this work can be done offline and there are no reasons why it should not be done offline. AssetBuilder turns an asset definition file in JSON format into a packed asset bundle file in a custom binary format suitable for fast loading.</description>
    </item>
    
    <item>
      <title>CIBot</title>
      <link>/projects/cibot/</link>
      <pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>/projects/cibot/</guid>
      <description>Abstract As mentioned in DirectXer, CIBot is my Continuous Integration and automation solution. I mainly developed CIBot because I didn&amp;rsquo;t want to deal with some other CI systems like Jenkins, GitHub actions, or whatever is popular right now. I wanted to have a system that is optimized for me, does not waste my time, has the features I need, and nothing more.
In the spirit of DirectXer, I decided to create this myself.</description>
    </item>
    
    <item>
      <title>Mission Control</title>
      <link>/projects/missioncontrol/</link>
      <pubDate>Mon, 26 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>/projects/missioncontrol/</guid>
      <description>.## Abstract {#abstract}
Mission Control is the product of my frustration with MSBuild and Visual Studio. Everything happens super slow in Visual Studio, if I want to make something happen, I always end up battling MSBuild configurations in the UI, things are not obvious, and all of this eats my time without giving me any deeper knowledge of&amp;hellip; anything really.
This led to me spending a week or two developing and fleshing out Mission Control &amp;ndash; tool written in C-styled C++ that uses nothing but Win32 libraries to do everything that it needs to.</description>
    </item>
    
    <item>
      <title>DirectXer</title>
      <link>/projects/directxer/</link>
      <pubDate>Sun, 25 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>/projects/directxer/</guid>
      <description>Abstract DirectXer started as a way for me learn DirectX11. Up until some point, I was familiar only with OpenGL and I wanted to learn THE mainstream API for graphics programming. DirectXer was the a project where I was experimenting and figuring things out about doing real-time rendering.
Over time, however, DirectXer evolved into my primary &amp;ldquo;code base&amp;rdquo; where I was doing everything, again in an experimental fashion. I was doing things like figuring out what memory management solution works best, how to do 3D and 2D rendering on the GPU, how to load my assets quicky, what is a good approach to doing UI in video games, and much more.</description>
    </item>
    
    <item>
      <title>Alisp</title>
      <link>/projects/alisp/</link>
      <pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/projects/alisp/</guid>
      <description>Abstract It&amp;rsquo;s has been a long standing idea of mine to just sit down and write a language. Not a complicated one, but also not completely useless one. Alisp is the crystallization of this idea into something concrete. It is a interpreted language based on Emacs-Lisp (elisp). I&amp;rsquo;ve borrowed a lot concepts from there and syntax-wise, Alisp closely follows elisp. By now the core runtime of the language is pretty feature complete and it is possible to run simple to moderately complicated programs.</description>
    </item>
    
    <item>
      <title>Code Manager</title>
      <link>/projects/code_manager/</link>
      <pubDate>Sat, 16 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/projects/code_manager/</guid>
      <description>Abstract This is my personal tool now for managing my GitHub repositories, some system software that I use and pretty much everything that can be downloaded, compiled locally and then installed on a Debian based Linux system. Through this utility one can quickly download and install random things from all over the internet. I&amp;rsquo;ve always wanted some small program that would allow me to quickly bring my GitHub repositories on my local machine so I end it up writing this in my spare time.</description>
    </item>
    
    <item>
      <title>Compile-Time Graph</title>
      <link>/projects/ctgraph/</link>
      <pubDate>Sat, 16 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/projects/ctgraph/</guid>
      <description>Abstract CTGraph is a small C++17 project that implements a graph structure that can be used entirely at compile time. It started as just an experiment. I wanted to see just how much computation I can perform at compile time. I was heavily inspired by part of cpp_box. In there Jason Turner has managed to implement a compile-time finite state machine. I thought that Graphs are not too far off of a finite state machine so I decided to give the idea a try.</description>
    </item>
    
    <item>
      <title>Alisp [PART 2]</title>
      <link>/projects/alisp_2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/projects/alisp_2/</guid>
      <description>Abstract In this post, I want to give a little more details on how Alisp can build from sources. ALisp is an interpreted language I&amp;rsquo;ve developed in C++. Over the last half a year, the project has become quite big (currently around 24K LOC) and thus the build process is so trivial as in the beginning. In the process of development, I&amp;rsquo;ve added numerous options for how the code can be compiled and all of those can be confusing at times.</description>
    </item>
    
  </channel>
</rss>
